
import { Product, PromoCode, User, StoreContent, SupportTicket, Subscriber, Order, AnalyticsEvent, Unsubscriber, SuspensionCase, Attachment } from '../types';
import { settingsService } from './settings';
import { api, API_ENDPOINTS } from './api';
import { securityService } from './security';

// --- In-Memory Cache ---
const productCache = new Map<string, Product>();
let allProductsCache: Product[] | null = null;
let allProductsTimestamp = 0;
const CACHE_TTL = 5 * 60 * 1000; // 5 Minutes

const DEFAULT_CONTENT: StoreContent = {
    policies: [
        { id: '1', title: 'Privacy Policy', slug: 'privacy-policy', content: '# Privacy Policy\n\nYour privacy is important to us. We only collect information necessary to process your order...' },
        { id: '2', title: 'Shipping Info', slug: 'shipping', content: '# Shipping Information\n\nWe ship worldwide! Standard shipping takes 3-5 business days.' },
        { id: '3', title: 'Returns', slug: 'returns', content: '# Returns & Exchanges\n\nWe offer a 30-day return policy for unused items in original packaging.' },
    ],
    marketing: {
        banner: { enabled: true, text: 'Free Shipping on Orders Over $50!', bgColor: '#000000', textColor: '#ffffff' },
        welcomePopup: { 
            enabled: false, 
            delay: 5, 
            title: 'Welcome!', 
            description: 'Get 10% off your first order.', 
            promoCode: 'WELCOME10',
            targetNonPurchasersOnly: false
        },
        exitPopup: {
            enabled: false,
            title: 'Wait!',
            description: 'Don\'t leave without your gift.',
            promoCode: 'SAVE15'
        },
        ads: {
            enabled: false,
            provider: 'adsense',
            placementLocations: [],
            script: ''
        }
    },
    socials: {
        instagram: 'https://instagram.com',
        twitter: 'https://twitter.com'
    },
    navCategories: ['T-Shirt', 'Mug', 'Art Print'],
    branding: {
        siteName: 'ShipTeez',
        logoUrl: '',
        logoMode: 'icon_text',
        logoScale: 100
    },
    theme: {
        primary: '#000000',
        secondary: '#f4f4f4',
        accent: '#3b82f6',
        background: '#ffffff',
        text: '#111827',
        fontFamily: 'Inter, sans-serif',
        borderRadius: '0px'
    },
    shipping: {
        baseRate: 5.99,
        additionalItemRate: 2.00,
        freeShippingThreshold: 50,
        enabled: true
    },
    shippingTemplates: [
        { id: 'default', name: 'Standard Shipping', baseRate: 5.99, additionalItemRate: 2.00 },
        { id: 'heavy', name: 'Heavy Goods', baseRate: 15.00, additionalItemRate: 5.00 }
    ],
    footer: {
        brandDescription: 'Curated, AI-designed merchandise. Each piece is unique, generated by state-of-the-art models and printed on demand.',
        shopHeader: 'Shop',
        supportHeader: 'Support',
        newsletterHeader: 'Stay in the loop',
        newsletterText: 'Get the latest AI drops and exclusive offers.',
        copyrightText: 'ShipTeez Store. All rights reserved.'
    },
    pageText: {
        accountWelcome: 'Hello, {name}',
        accountSupportIntro: 'Need help? Create a new ticket.',
        loginTitle: 'Welcome Back',
        loginSubtitle: 'Sign in to access your orders and wishlist.',
        registerTitle: 'Create Account',
        registerSubtitle: 'Join ShipTeez today.',
        chatbotSystemPrompt: 'You are a helpful, friendly customer support assistant for "ShipTeez". You answer questions about shipping (3-5 days), returns (30 days), and product quality (high quality ceramic/cotton). Be concise and polite.'
    },
    security: {
        enableCaptcha: true,
        adminIps: [],
        maxLoginAttempts: 5,
        blockTorExitNodes: false,
        enableFingerprinting: true,
        sessionTimeoutMinutes: 60,
        blockDisposableEmails: true,
        maxCardAttempts: 3,
        strictAddressValidation: false,
        blockedIPs: ''
    },
    emailSettings: {
        senderName: 'ShipTeez Team',
        replyToEmail: 'support@shipteez.com',
        headerHtml: '<div style="font-family: sans-serif; padding: 20px;">',
        footerHtml: '<div style="margin-top: 40px; font-size: 12px; color: #888; border-top: 1px solid #eee; padding-top: 20px;">Â© {year} {storeName}. All rights reserved.<br/><a href="{unsubscribeLink}">Unsubscribe</a></div></div>',
        footerText: ''
    },
    emailTemplates: [
        { 
            id: 'welcome', 
            name: 'Welcome Email', 
            subject: 'Welcome to ShipTeez!', 
            body: '<p>Hi {name},</p><p>Thanks for joining our community of AI art enthusiasts. Check out our latest drops!</p><p>Cheers,<br>ShipTeez</p>' 
        },
        { 
            id: 'order_conf', 
            name: 'Order Confirmation', 
            subject: 'Order Confirmation #{orderId}', 
            body: '<p>Hi {name},</p><p>Thank you for your order! We are processing it now.</p><p><b>Order #{orderId}</b><br>Total: ${total}</p><p>You can track your order status in your account.</p>' 
        },
        { 
            id: 'shipping_notif', 
            name: 'Shipping Notification', 
            subject: 'Your order #{orderId} has shipped!', 
            body: '<p>Hi {name},</p><p>Great news! Your order #{orderId} is on its way.</p><p><b>Tracking Number:</b> {trackingNumber}</p><p><a href="{trackingLink}">Track your package here</a></p>' 
        },
        { 
            id: 'reset_pass', 
            name: 'Password Reset', 
            subject: 'Reset Your Password', 
            body: '<p>Use this token to reset your password: <b>{token}</b></p>' 
        },
        {
            id: 'newsletter_promo',
            name: 'Newsletter / Promotion',
            subject: 'Exclusive Offer inside!',
            body: '<p>Hi {name},</p><p>Check out our new collection of AI-generated mugs. Use code <b>SUMMER20</b> for 20% off!</p><button>Shop Now</button>'
        },
        {
            id: 'verify_email',
            name: 'Verify Email',
            subject: 'Verify your subscription',
            body: '<p>Hi,</p><p>Please verify your email subscription by clicking the link below:</p><p><a href="{verificationLink}">Verify Email</a></p>'
        },
        {
            id: 'account_suspended',
            name: 'Account Suspended',
            subject: 'Important: Your Account Status',
            body: '<p>Hi {name},</p><p>Your account has been temporarily suspended due to a violation of our terms or suspicious activity.</p><p><b>Reason:</b> {reason}</p><p>If you believe this is an error, please log in to your account dashboard to submit an appeal and provide verification documents.</p>'
        },
        {
            id: 'account_restored',
            name: 'Account Restored',
            subject: 'Account Restored',
            body: '<p>Hi {name},</p><p>Great news! We have reviewed your case and your account access has been fully restored.</p><p>You can now log in and place orders as normal.</p>'
        }
    ],
    sizeGuides: [
        {
            id: 'sg_tshirt',
            category: 'T-Shirt',
            title: 'Unisex T-Shirt Sizing',
            content: '| Size | Width (in) | Length (in) |\n|---|---|---|\n| S | 18 | 28 |\n| M | 20 | 29 |\n| L | 22 | 30 |\n| XL | 24 | 31 |\n| 2XL | 26 | 32 |'
        },
        {
            id: 'sg_mug',
            category: 'Mug',
            title: 'Ceramic Mug Dimensions',
            content: '| Size | Capacity | Height | Diameter |\n|---|---|---|---|\n| Standard | 11oz | 3.75" | 3.15" |\n| Large | 15oz | 4.73" | 3.15" |'
        }
    ],
    layout: [
        { 
            id: 'hero', 
            type: 'Hero', 
            isEnabled: true, 
            order: 0, 
            title: 'Hero Banner',
            styles: { backgroundColor: '#000000', textColor: '#ffffff', textAlign: 'center', height: '600px', padding: '0', backgroundImage: '' },
            config: { heading: 'ShipTeez Collection', subheading: 'Discover unique, AI-generated designs.', buttonText: 'Shop Now' }
        },
        { 
            id: 'featured', 
            type: 'Featured', 
            isEnabled: true, 
            order: 2, 
            title: 'Featured Collection',
            config: { sourceType: 'random', limit: 4 }
        },
        { 
            id: 'grid', 
            type: 'ProductGrid', 
            isEnabled: true, 
            order: 3, 
            title: 'Shop All' 
        }
    ]
};

// Helper for Auth Token
const getUserToken = async (): Promise<string | undefined> => {
    const saved = localStorage.getItem('artisan_user_enc');
    if (!saved) return undefined;
    try {
        const user = await securityService.decrypt(saved);
        return user?.token;
    } catch {
        return undefined;
    }
};

// --- Remote DB Implementation ---
export const db = {
    // Newsletter & Subs
    subscribeNewsletter: async (email: string): Promise<void> => {
        const s = await settingsService.load();
        try {
            await fetch(`${s.apiUrl}${API_ENDPOINTS.newsletter.subscribe}`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ email })});
        } catch (e) {
            console.warn("Subscribe failed", e);
            throw e;
        }
    },
    unsubscribeNewsletter: async (email: string): Promise<void> => {
        const s = await settingsService.load();
        try {
            await api.unsubscribeNewsletter(s, email);
        } catch (e) {
            console.warn("Unsubscribe failed", e);
            throw e;
        }
    },
    verifyEmail: async (token: string): Promise<void> => {
        const s = await settingsService.load();
        await api.verifyEmail(s, token);
    },
    getNewsletterSubscribers: async (): Promise<Subscriber[]> => {
        const s = await settingsService.load();
        try {
            const token = await getUserToken();
            return await api.getNewsletterSubscribers(s, token);
        } catch (e) { 
            console.warn("Subs fetch failed", e); 
            return [];
        }
    },
    getUnsubscribers: async (): Promise<Unsubscriber[]> => {
        const s = await settingsService.load();
        try {
            const token = await getUserToken();
            return await api.getUnsubscribers(s, token);
        } catch (e) {
            console.warn("Unsub fetch failed", e);
            return [];
        }
    },
    addUnsubscriber: async (email: string): Promise<void> => {
        const s = await settingsService.load();
        const token = await getUserToken();
        await api.addUnsubscriber(s, email, token);
    },
    removeUnsubscriber: async (email: string): Promise<void> => {
        const s = await settingsService.load();
        const token = await getUserToken();
        await api.removeUnsubscriber(s, email, token);
    },
    deleteSubscriber: async (email: string): Promise<void> => {
        // Just use unsubscribe logic which removes from active and adds to unsub list
        return db.unsubscribeNewsletter(email);
    },
    cleanupSubscribers: async (hours: number): Promise<number> => {
        // Placeholder
        return 0;
    },
    
    // Products
    getAllProducts: async () => {
        const now = Date.now();
        if (allProductsCache && (now - allProductsTimestamp < CACHE_TTL)) {
            return allProductsCache;
        }

        const s = await settingsService.load();
        try {
            const res = await fetch(`${s.apiUrl}${API_ENDPOINTS.products.list}`);
            if (res.ok) {
                const data = await res.json();
                allProductsCache = data;
                allProductsTimestamp = now;
                // Hydrate individual cache
                data.forEach((p: Product) => productCache.set(p.id, p));
                return data;
            }
        } catch(e) { console.warn('Fetch products failed', e); }
        return [];
    },
    getProduct: async (id: string) => {
        if (productCache.has(id)) {
            return productCache.get(id);
        }
        
        // Fallback to searching all (since we usually load all at once for this scale)
        const all = await db.getAllProducts();
        return all.find((p: Product) => p.id === id || p.slug === id);
    },
    prefetchProduct: async (id: string) => {
        if (productCache.has(id)) return;
        
        // Simulating a targeted fetch, though for now we rely on getAllProducts
        // In a real REST API, this would be `fetch(/api/products/${id})`
        const all = await db.getAllProducts(); 
        const found = all.find((p: Product) => p.id === id);
        if (found) productCache.set(id, found);
    },
    
    saveProduct: async (p: Product) => {
        const s = await settingsService.load();
        try {
            const token = await getUserToken();
            await fetch(`${s.apiUrl}${API_ENDPOINTS.products.list}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                body: JSON.stringify(p)
            });
            // Invalidate Cache
            allProductsCache = null;
            productCache.delete(p.id);
        } catch(e) { console.warn("Save product failed", e); throw e; }
    },
    
    deleteProduct: async (id: string) => {
        const s = await settingsService.load();
        try {
            const token = await getUserToken();
            await fetch(`${s.apiUrl}${API_ENDPOINTS.products.deleteBatch}`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                body: JSON.stringify({ ids: [id] })
            });
            // Invalidate Cache
            allProductsCache = null;
            productCache.delete(id);
        } catch(e) { throw e; }
    },
    
    deleteProducts: async (ids: string[]) => {
        const s = await settingsService.load();
        try {
            const token = await getUserToken();
            await fetch(`${s.apiUrl}${API_ENDPOINTS.products.deleteBatch}`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                body: JSON.stringify({ ids })
            });
            // Invalidate Cache
            allProductsCache = null;
            ids.forEach(id => productCache.delete(id));
        } catch(e) { throw e; }
    },
    
    clearDatabase: async () => {
        // Admin only, risky, not implemented in standard flow
    },
    
    // Promos
    getAllPromos: async () => {
        const s = await settingsService.load();
        try {
            const res = await fetch(`${s.apiUrl}${API_ENDPOINTS.promos.list}`);
            if (res.ok) return await res.json();
        } catch(e) {}
        return [];
    },
    savePromo: async (p: PromoCode) => {
        const s = await settingsService.load();
        try {
            const token = await getUserToken();
            await fetch(`${s.apiUrl}${API_ENDPOINTS.promos.list}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` },
                body: JSON.stringify(p)
            });
        } catch(e) { throw e; }
    },
    deletePromo: async (c: string) => {
        const s = await settingsService.load();
        try {
            const token = await getUserToken();
            await fetch(`${s.apiUrl}${API_ENDPOINTS.promos.detail(c)}`, {
                method: 'DELETE',
                headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${token}` }
            });
        } catch(e) { throw e; }
    },
    trackPromoUsage: async (c: string) => {
        // Implement tracking endpoint if needed
    }, 
    
    getAllUsers: async (): Promise<User[]> => {
        const s = await settingsService.load();
        try {
            const token = await getUserToken();
            if (!token) return [];
            return await api.getUsers(s, token);
        } catch (e) {
            console.warn("Failed to fetch users", e);
            return [];
        }
    },
    toggleUserSuspension: async (id: string, isSuspended: boolean, reason?: string) => {
        try {
            const s = await settingsService.load();
            const token = await getUserToken();
            if (!token) throw new Error("No admin token available");
            await api.suspendUser(s, id, isSuspended, reason || "Violation of terms", token);
        } catch (e: any) {
            console.error("DB Service: Toggle Suspension Failed", e);
            throw e; // Re-throw to let UI handle the error alert
        }
    },
    deleteUser: async (id: string) => {
        // Placeholder
    },
    updateUser: async (id: string, data: Partial<User> & { password?: string }) => {
        const s = await settingsService.load();
        try {
            const token = await getUserToken();
            await api.updateUser(s, id, data, token);
        } catch (e) { throw e; }
    },
    
    // Content
    getStoreContent: async () => {
        const s = await settingsService.load();
        try {
            const res = await fetch(`${s.apiUrl}${API_ENDPOINTS.content.main}`);
            if (res.ok) {
                const remoteData = await res.json();
                return { ...DEFAULT_CONTENT, ...remoteData };
            }
        } catch (e) { console.warn("Content fetch failed", e); }
        // Fallback to defaults if remote fails, so the app still renders
        return DEFAULT_CONTENT;
    },
    saveStoreContent: async (c: StoreContent) => {
        const s = await settingsService.load();
        try {
            const token = await getUserToken();
            const res = await fetch(`${s.apiUrl}${API_ENDPOINTS.content.main}`, {
                method: 'POST',
                headers: { 
                    'Content-Type': 'application/json',
                    ...(token ? { 'Authorization': `Bearer ${token}` } : {})
                },
                body: JSON.stringify(c)
            });
            if(!res.ok) throw new Error("Failed to save content remote");
        } catch (e) { console.warn("Content save failed", e); throw e; }
    },
    getCategories: async () => {
        const s = await settingsService.load();
        try {
            return await api.getCategories(s);
        } catch(e) {
            // Fallback: extract from products
            const products = await db.getAllProducts();
            const set = new Set<string>();
            products.forEach((p: Product) => set.add(p.category));
            return Array.from(set);
        }
    },
    createTicket: async (subject: string, message: string, orderId?: string) => {
        const s = await settingsService.load();
        const token = await getUserToken();
        return api.createTicket(s, subject, message, orderId, token);
    },
    getUserTickets: async () => {
        const s = await settingsService.load();
        const token = await getUserToken();
        return api.getUserTickets(s, token);
    },
    getAdminTickets: async () => {
        const s = await settingsService.load();
        const token = await getUserToken();
        return api.getAdminTickets(s, token);
    },
    replyTicket: async (id: string, text: string, role: 'user' | 'admin', attachments?: Attachment[]) => {
        const s = await settingsService.load();
        const token = await getUserToken();
        return api.replyTicket(s, id, text, role, attachments, token);
    },
    updateTicketStatus: async (id: string, status: 'Open' | 'Closed') => {
        const s = await settingsService.load();
        const token = await getUserToken();
        return api.updateTicketStatus(s, id, status, token);
    },
    
    // --- Suspension Appeals ---
    getSuspensionCase: async (userId: string): Promise<SuspensionCase | null> => {
        const s = await settingsService.load();
        const token = await getUserToken();
        try {
            return await api.getSuspensionCase(s, userId, token);
        } catch(e) { return null; }
    },
    appealSuspension: async (statement: string) => {
        const s = await settingsService.load();
        const token = await getUserToken();
        await api.appealSuspension(s, statement, token);
    },
    uploadAppealDoc: async (type: string, file: File) => {
        const s = await settingsService.load();
        const token = await getUserToken();
        
        // Convert to base64
        const reader = new FileReader();
        const base64 = await new Promise<string>((resolve) => {
            reader.onload = () => resolve(reader.result as string);
            reader.readAsDataURL(file);
        });
        
        return await api.uploadAppealDoc(s, type, base64, token);
    },
    resolveAppeal: async (userId: string, action: 'unsuspend' | 'reject', notes: string) => {
        const s = await settingsService.load();
        const token = await getUserToken();
        await api.resolveAppeal(s, userId, action, notes, token);
    },

    // --- Order Management ---
    createOrder: async (order: Order) => {
        const s = await settingsService.load();
        // Optional token (Guest checkout vs logged in)
        const token = await getUserToken(); 
        return api.createOrder(s, order, token);
    },
    getAllOrders: async () => {
        const s = await settingsService.load();
        const token = await getUserToken();
        return api.getAllOrders(s, token);
    },
    updateOrder: async (order: Order) => {
        // Since we are usually just appending logs or changing status, create works as upsert in simple backends
        const s = await settingsService.load();
        const token = await getUserToken();
        // Re-use create endpoint with upsert logic in backend
        return api.createOrder(s, order, token); 
    },

    // --- Wallet Management ---
    getWallet: async () => {
        const s = await settingsService.load();
        const token = await getUserToken();
        if (!token) return [];
        return api.getWallet(s, token);
    },
    deletePaymentMethod: async (id: string) => {
        const s = await settingsService.load();
        const token = await getUserToken();
        if (!token) throw new Error("Not logged in");
        return api.deletePaymentMethod(s, id, token);
    },

    logEvent: async (e: AnalyticsEvent) => { /* Placeholder for remote analytics */ },
    getAnalyticsEvents: async () => [],
};
